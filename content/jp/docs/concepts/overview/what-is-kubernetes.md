---
reviewers:
title: Kubernetes とは何か？
content_template: templates/concept
weight: 10
---

{{% capture overview %}}
このページは Kubernetes 概要です。
{{% /capture %}}

{{% capture body %}}
Kubernetes はコンテナ化したワークロードやサービスを管理するための、ポータブルで拡張性があるオープンソースのプラットフォームであり、宣言型設定と自動化の両方を調整します。
Kubernetes には大きく急成長したエコシステムがあります。
Kubernetes のサービス、サポート、ツールは広範囲にわたって利用できます。

Google は Kubernetes プロジェクトを 2014 年にオープンソース化しました。
Kubernetes は [decade and a half of experience that Google has with running production workloads at scale](https://research.google.com/pubs/pub43438.html)（Google が大規模な本番用ワークロードを実行した、15年にわたる経験）を踏まえて構築されており、コミュニティによる最善のアイディアと実践が組み合わさっています。

## どうして Kubernetes が必要で、何ができるのでしょうか？ {#why-do-i-need-kubernetes-and-what-can-i-do}

Kubernetes は多くの機能を持ちます。考えられ得るのは、以下の通りです：

- コンテナ基盤（container platform）
- マイクロサービス基盤（microservices platform）
- ポータブルなクラウド基盤（portable cloud platform）

など様々です。

Kubernetes は **コンテナ中心（container-centric）**  の管理環境を備えています。
ユーザの作業負担に代わり、Kubernetes が計算（computing）、ネットワーク構築（networking）、ストレージ基盤（storage infrastructure）をオーケストレートします。
Kubernetes がもたらすのは、サービスとしての基盤（IaaS）が柔軟であるサービスとしてのプラットフォーム（PaaS）をとてもシンプルなものにし、基盤事業者を横断可能にするポータビリティを実現します。

## どのようにして Kubernetes をプラットフォームにするのですか？ {#how-is-kubernetes-a-platform}

Kubernetes は多くの機能性を提供しますが、新機能の利点がもたらす新しいシナリオが常にあります。
アプリケーション固有のワークフローは無駄を無くして合理化できるため、開発者の勢いを加速します。
臨機応変なオーケストレーションのためには、初期の段階からしっかりとした自動化が大規模に必要なのを受け入れなくてはいけません。
また、これこそがなぜ Kubernetes がエコシステムのコンポーネントとツールによるプラットフォームを提供できるように設計されているかであり、これにより、アプリケーションのデプロイ、スケール、管理を簡単にします。

[ラベル（label）](/jp/docs/concepts/overview/working-with-objects/labels/)はユーザに対して満足なリソースの整理を可能にします。
[アノテーション（annotation）](/jp/docs/concepts/overview/working-with-objects/annotations/)はリソースに対してワークフローに役立つカスタム情報を付与できるようにし、管理ツールに対するチェックポイントの提供を簡単にします。

さらに、[Kubernetes コントロール・プレーン](/jp/docs/concepts/overview/components/) は、開発者とユーザが利用できる共通の [APIs](/jp/docs/reference/using-api/api-overview/) 上で構築されています。
ユーザは汎用的な [コマンドライン・ツール](/jp/docs/user-guide/kubectl-overview/) を目的として、自分で [スケジューラ](https://github.com/kubernetes/community/blob/{{< param "githubbranch" >}}/contributors/devel/scheduler.md) のようなコントローラを [自分の API ](/jp/docs/concepts/api-extension/custom-resources/) で書けます。

## Kubernetes は何ではないか {#what-kubernetes-is-not}


Kubernetes は旧来からの包括的な PaaS（サービスとしてのプラットフォーム）システムではありません。
Kubernetes が扱うのはハードウェア面というよりは、コンテナ面だからです。
いくつかの機能は PaaS が提供するものと共通でしょう。たとえば配置（デプロイ）、規模の拡大縮小（スケール）、負荷分散、ログ記録、監視です。
しかしながら、Kubernetes はモノリシック（一枚岩的な構造）ではありません。
また、これら標準的な機能に対する解決法は任意（オプション）であり、取り付け・取り外しが自由（プラガブル）です。
Kubernetes が提供するのは開発者基盤を構築するための基本的要素ですが、ユーザによる選択と柔軟性を保持する所こそが重要です。

Kubernetes とは：

* 扱うアプリケーションの種類に制限はありません。Kubernetes は非常に様々な多様性のあるワークロードのサポートを目標としています。ワークロードにはステートレス（stateless）、ステートフル（statefull）、データ処理を含みます。アプリケーションをコンテナとして実行可能であれば、大いに Kubernetes で実行すべきでしょう。
* ソースコードの配置（デプロイ）やアプリケーションの構築をしません。継続的インテグレーション、デリバリ、デプロイ（CI/CD）の作業手順を決めるのは、組織文化と優先度だけでなく、技術的な要件も同様です。
* アプリケーション面でのサービスは提供しません。たとえば、ミドルウェア（例：メッセージ・バス）、データ処理フレームワーク（例：Spark）、データベース（例：mysql）、キャッシュだけでなく、クラスタ・ストレージ・システム（例：Cepth）を内蔵サービス（built-in services）として提供しません。コンポーネントによっては Kubernetes 上で実行できないか、あるいは、Kubernetes 上で動作するアプリケーションが Open Service Broker のようなポータブルな仕組みを通さないと通信できません。
* ログ記録、監視、通報（アラート）に対処する解決策（ソリューション）はありません。概念実証（PoC：Proof of Concept）としての機能統合と、監視用指標（metric）の収集と出力に関する仕組みがいくつかあります。
* 設定言語システム（ 例：[jsonnet](https://github.com/google/jsonnet)）を提供しませんし、委任もしません。提供するのは宣言型 API であり、宣言型仕様によって形成されているものも対象になる場合があります。

さらに付け加えると、Kubernetes は単なる  *オーケストレーション・システム（orchestration system）*  ではありません。
実際には *オーケストレーション* の必要性を排除します。 
*オーケストレーション（orchestration）* の技術的な定義は、定義したワークフロー（作業手順）の実行です。
つまり、まず A を処理し、つぎは B、そして C です。
これに対し、Kubernetes は独立した制御プロセスの集まりで構成されており、
現在の状態が指定した期待状態に向かうよう継続的に駆動します。
どのように A から C に至るかは問題としません。
また、制御を中心に集約する必要もありません。
この結果、簡単に使用でき、より強力で、堅牢、弾力的かつ拡張可能なシステムになりました。

## なぜコンテナですか？ {#why-containers}

なぜコンテナを使うべきかの理由をお探しですか。

![Why Containers?](/images/docs/why_containers.svg)

アプリケーションをデプロイする *古い手法* は、オペレーティングシステムのパッケージ・マネージャを使い、ホスト上にアプリケーションをインストールすることでした。
これはアプリケーションとして実行するもの、設定ファイル、ライブラリ、ライフサイクルがホスト OS やその他に巻き込まれる不都合がありました。
ロールアウト（展開）とロールバック（巻き戻し）を予測可能にするために、内容が変わらない（イミュータブルな）仮想マシン・イメージを使う方法がありました。
しかし、仮想マシンは巨大で重く、ポータビリティがありません。

*新しい手法* とは、オペレーティングシステム面での仮想化に基づくコンテナのデプロイであり、ハードウェア仮想化ではありません。
これらのコンテナは相互かつホストからも隔てられています。
コンテナは各々でファイルシステムを持つため、他のプロセスのものを見られません。
それに、計算資源の使用率が跳ね上がっても分かりません。
コンテナは仮想マシンを構築するよりも簡単です。
それに、基礎をなす基盤（インフラ）とホスト・ファイルシステムからは切り離されるため、クラウドと OS ディストリビューションを横断して移動できます。

コンテナは小さくて速いため、アプリケーションの１つ１つを、それぞれコンテナ・イメージに格納できます。
このアプリケーションとイメージが１対１で対応する関係が、コンテナの利点すべてを解き放ちます。
コンテナと一体である、不変な（イミュータブル）コンテナ・イメージにより、デプロイの時間よりも、構築・リリースのための時間を生み出します。
これは各アプリケーションがアプリケーションの積み重ね（stack：スタック）に要らないものを組み込む必要がないだけでなく、本番向け基盤環境とも深く関与するからです。
コンテナ・イメージを構築・リリースする時間がもたらすのは、開発環境から本番向けへの移動（運搬）が一貫している環境です。
同様に、コンテナは VM に比べて非常に透過的なため、監視と管理が容易になります。
コンテナのプロセス・ライフサイクルがコンテナ内のプロセス・スーパーバイザによって隠されているというよりは、基盤によって管理されているというのが実体でしょう。最後に、コンテナごとに１つのアプリケーションであれば、コンテナの管理と、アプリケーションを配置（デプロイ）する管理が等しいも同然です。

コンテナ利点の概要：

* **素早いアプリケーション作成と配置（デプロイ）** ：仮想マシン・イメージの利用と比べ、コンテナ・イメージの作成は、簡単さと効率性が向上する。
* **継続的な開発、インテグレーション、配置（デプロイ）** ：信頼性をもたらし、頻繁なコンテナ・イメージの構築・配置を素早く行え、ロールバック（巻き戻し）が簡単（イメージが不変のため）。
* **開発担当（Dev）と運用担当（Ops）の懸念事項を分離** ：アプリケーション・コンテナ・イメージを配置（デプロイ）する時間より、構築/リリース時間のほうが増えるため、結果としてアプリケーションを基盤（インフラ）から切り離せるようにする。
* **観測可能性（Observability：オブサーバビリティ）** ：OS 面で出てくる情報と測定値（metric：メトリック）だけでなく、アプリケーションの正常性（health）や他の指標。
* **開発、テスト、本番にわたる一貫した環境** ：ノート PC 上で実行するものと、クラウド上で実行するものが同じ。
アプリケーション中心の管理：アプリケーションは OS の論理的な資源（リソース）を使用するため、仮想ハードウェア上での OS 実行よりも抽象化の度合いが高まる。
* **疎結合（loosely coupled）、分散、弾力性、解放されたマイクロサービス** ：個々の部品に小さく分割されたアプリケーションを配置（デプロイ）かつ動的に管理できるようにする。これは一枚岩の層（monolistic stack）を大きな単一目的のマシン上で実行するのとは異なる。
* **資源の分離**：アプリケーション性能を予測可能にする。
* **資源の活用**：高効率と高密度。

## Kubernetes とはどのような意味ですか？ K8s とは？ {#what-does-kubernetes-mean-k8s}

**Kubernetes** の名前はギリシャ語に由来しており、意味は 操舵手（helmsman） や 水先案内人（pilot） です。
そして、これは *governor* と [cybernetic](http://www.etymonline.com/index.php?term=cybernetics) の語源でもあります。
“K8s” は “ubernete” を “8” で省略している所からきています。

{{% /capture %}}

{{% capture whatsnext %}}
*   [導入](/jp/docs/setup/) の準備は整いましたか？
*   詳細な情報は[Kubernetes ドキュメント](/jp/docs/home/) をご覧ください。
{{% /capture %}}


