---
title: ポッド概要
content_template: templates/concept
weight: 10
---

{{% capture overview %}}
このページは `Pod` （ポッド）の概要を紹介します。
ポッドとは Kubernetes オブジェクト・モデルにおいて最小の展開可能なオブジェクトです。

{{% /capture %}}

{{< toc >}}

{{% capture body %}}

## ポッドの理解 {#understanding-pods}

*ポッド（Pod）* は Kubernetes における基本的な構築要素です。
Kubernetes オブジェクト・モデルで作成・展開できる、最小かつ最もシンプルな単位（ユニット）です。
ポッドはクラスタ上で実行中のプロセスに相当します。

ポッドが収容するのは、アプリケーション・コンテナ（または、時として複数のコンテナ）、ストレージ・リソース、ユニークなネットワーク IP 、そして、どのようにコンテナを実行すべきかを管理するオプションです。
ポッドは展開（デプロイ）の単位を表します。
すなわち、 *Kubernetes におけるアプリケーション１つのインスタンス（実体）* です。ポッドに含まれるのは、１つのコンテナに限りません。密結合の小数コンテナがリソースを共有する場合もあります。

[Docker](https://www.docker.com) は Kubernetes ポッドとして最も一般的に使われるコンテナ・ランタイムです。
しかし、ポッドは他のコンテナ・ランタイムも同様にサポートします。

Kubernetes クラスタにおいて、ポッドは主に２つの方法で使われます：

* **１つのコンテナを実行するポッド** 。 "ポッドごとに１つのコンテナ" モデルは、Kubernetes で最も共通する使い方です。この場合、１つのコンテナを囲むラッパーとして、ポッドを考えられます。そして、Kubernetes はコンテナの管理を直接ではなく、ポッドを通して行います。
* **同時に動かす必要のある複数のコンテナを実行するポッド** 。ポッドは、同一の場所にある複数のコンテナによって構成されるアプリケーションをカプセル化している場合があります。ポッド内のコンテナは密結合であり、リソースを共有する必要があります。これら同一の場所にあるコンテナは、１つの密接なサービス単位です。たとえば、あるコンテナが提供する共有ボリューム上のファイルを、別の「サイドカー」（sidecar）コンテナが各ファイルを再読み込みまたは更新して公開します。ポッドはこれらのコンテナとストレージ・リソースを１つの管理可能な存在としてラップします（包みます）。

[Kubernetes Blog](http://blog.kubernetes.io) にPod 利用例の追加情報があります。詳しい情報はこちらをご覧ください：

* [分散システム・ツールキット：複数のコンテナ用パターン](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns)
* [コンテナ・デザイン・パターン](https://kubernetes.io/blog/2016/06/container-design-patterns)

各ポッドが意図しているのは、あるアプリケーション実体（インスタンス）１つの実行です。
もしもアプリケーションを水平にスケールしたい場合は（例：複数のインスタンスを実行したい場合）、インスタンスを１つ１つ使うのではなく、ポッドを使うべきです。
Kubernetes では、通常これを *レプリケーション（replication）* としてみなします。
複製されたポッドの作成と管理は、コントローラ（controller）と呼ばれる抽象化されたグループによって行われます。
詳しい情報は [ポッドとコントローラ](#pods-and-controllers) をご覧ください。

### ポッドは複数のコンテナをどのように管理するか {#how-pods-manage-multiple-containers}

ポッドは、密接なサービス単位からなる複数のプロセス（をコンテナとして）の協調をサポートするように設計されています。
ポッド内のコンテナは、クラスタ内の同じ物理または仮想マシン上へ自動的に配置（co-located）され、また、同時にスケジュール（co-scheduled）されます。
コンテナはリソースと依存関係を共有でき、他のコンテナとも通信可能であり、いつどのようにコンテナが停止したとしても調整を行います。

１つのポッド内で、コンテナを同じ場所で同時にグループ化して管理する場合は、比較的に難しい使い方になりますので注意してください。
このパターンが使えるのは、コンテナ間が密結合である特別なパターンの時のみでしょう。
たとえば、共有ボリュームにあるファイルをウェブ・サーバとして処理するコンテナを持っているとします。
また、別の "sidecar"（サイドカー）コンテナが、次の図のように、リモート上のソースからファイルを更新するとします。

{{< figure src="/images/docs/pod.svg" title="ポッド図" width="50%" >}}

ポッドが提供するのは、コンテナの構成要素となる2種類の共有リソース *ネットワーキング* と *ストレージ* です。

#### ネットワーキング {#networking}

各ポッドにはユニークな IP アドレスが割り当てられます。
ポッド内の各コンテナはネットワーク名前空間を共有します。これには IP アドレスとネットワーク・ポートも含みます。
*ポッド内部の* コンテナは、 `localhost` を使って他と通信できます。
ポッド内のコンテナが *ポッド外部の* 存在と通信する場合は、ネットワーク・リソース（ポートなど）を共有するために使う手法を調整する必要があります。

#### ストレージ {#storage}

ポッドは共有ストレージを *ボリューム（volume）* として指定できます。
ポッド内の全てのコンテナが共有ボリュームに接続できます。
これにより、各コンテナはデータを共有できます。
また、再起動が必用なコンテナがあったとしても、ポッド内のボリュームに持続データを保管できます。
ポッド内で Kubernetes がストレージをどのようにして共有するか、この詳しい情報は [ボリューム](/jp/docs/concepts/storage/volumes/) をご覧ください。

## ポッドと連携するには {#working-with-pods}

Kubernetes では個々のポッドを直接作成するのは滅多にありません。たとえ１つのポッドだとしてもです。
これはポッドが比較的に一過性（ephemeral）で使い捨て可能ものとして設計されているためです。
ポッドが作成されると（直接、あるいはコントローラによって間接的に）、クラスタ上のノードでの実行がスケジュールされます。
ポッドはノードでプロセスが停止（terminate）されるまで残り続けます。
ポッド・オブジェクトが削除されると、ポッドはリソースが欠如により *撤去（evicted）* されます。
そうでない場合は、ノードが処理の失敗（fail）となります。

{{< note >}}
**メモ：** ポッド内のコンテナ再起動は、ポッドの再起動と混同すべきではありません。
ポッド自身は実行しませんが、コンテナを実行するための環境とその維持が、削除されるまで続きます。
{{< /note >}}

ポッドが行わないのは、ポッド自身の自己修復（self-heal）です。
ノードに対するポッドのスケジュールが失敗するか、あるいは、スケジュール作業そのものが失敗すると、ポッドは削除されます。
さらに、ポッドはリソース不足によって退去される場合、ノードのメンテナンスの場合も、そのまま存続できません。
Kubernetes は *コントローラ（Controller）* と呼ぶ、高いレベルでの抽象化を使います。
コントローラは比較的使い捨てのポッド・インスタンス（そのもの／実体）を管理する作業を扱います。

### ポッドとコントローラ {#pods-and-controllers}

コントローラは複数のポッドの作成と管理ができます。
コントローラはクラスタの範囲内において、レプリケーション（複製）とロールアウト（展開）の処理と、自己修復能力を提供します。
たとえば、ノードで障害が起これば、コントローラは自動的にポッドを置き換えるため、直ちに別のノード上への配置転換をスケジューリング（計画）します。

以下は１つまたは複数のポッドを含むコントローラの例です：

* [Deployment（デプロイメント）](/jp/docs/concepts/workloads/controllers/deployment/)
* [StatefulSet（ステートフルセット）](/jp/docs/concepts/workloads/controllers/statefulset/)
* [DaemonSet（デーモンセット）](/jp/docs/concepts/workloads/controllers/daemonset/)

通常、コントローラはポッド・テンプレートを使い、コントローラが責任を負うポッドを作成します。

## ポッド・テンプレート（Pod Templates） {#pod-templates}

ポッド・テンプレートとはポッドの仕様であり、
[Replication Controllers（レプリケーション・コントローラ）](/docs/concepts/workloads/controllers/replicationcontroller/)、 [ジョブ](/docs/concepts/jobs/run-to-completion-finite-workloads/)、 [DaemonSets（デーモンセット）](/docs/concepts/workloads/controllers/daemonset/) のような他のオブジェクトを含みます。コントローラは実際のポッドを作成するために、ポッド・テンプレートを使います。以下の例はポッド向けの簡単なマニフェストです。ポッドに含まれるコンテナはメッセージを表示します。


```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']
```

全ての複製（レプリカ）に対して期待状態を指定するのに比べれば、ポッド・テンプレートはクッキーの抜き型（cookie cutter）のようなものです。
クッキーをカッターを使って切り離したあとは、クッキーとカッターは何の関係も持ちません。
ここには「量子もつれ（quantum entanglement）」はありません。
テンプレートの変更後や、新しいテンプレートに切り替えた後も、既に作成したポッドに対しては何ら影響を与えません。
一方で、レプリケーション・コントローラによって作成されたポッドであれば、その後も直接更新できます。
これがポッドと比べて考慮が必要な点です。
ポッドでであれば現時点における全コンテナの期待状態を指定するからです。
この手法はシステムの形式化（セマンティクス）を極めて簡単にし、初期状態（プリミティブ）の柔軟性も高めます。

{{% /capture %}}

{{% capture whatsnext %}}
* ポッドの挙動について学ぶ：
  * [ポッドの停止](/jp/docs/concepts/workloads/pods/pod/#termination-of-pods)
  * 他のポッドの話題

{{% /capture %}}


