---
title: ポッド
content_template: templates/concept
weight: 20
---

{{% capture overview %}}

_ポッド（Pod）_ とは、Kubernetes が作成・管理できる計算用の最小デプロイ単位です。

{{% /capture %}}

{{< toc >}}

{{% capture body %}}

## ポットとは何でしょうか？ {#what-is-a-pod}

_ポッド（Pod）_ （意味は鯨の群れ、あるいは、豆の鞘）とは、１つまたは複数のコンテナ（Docker コンテナなど）のグループであり、ストレージとネットワークを共有し、コンテナをどのように実行するかの仕様を持ちます。
ポッドに含まれるものは、共有のコンテクスト（訳者注：プロセス実行に必要な最小のデータ・セット）において、常に一緒の場所で、同時にスケジュール（実行を予定）し、実行します。
ポッドのモデル（雛形）となるのは、アプリケーション固有の「論理的なホスト」であり、ここには１つまたは比較的に関連性の強いそれ以上のアプリケーション・コンテナが入っています。
このアプリケーションは、コンテナが登場する前の世界では、同じ物理もしくは仮想マシン上で実行されるべきものでした。

kubernetes は Docker のような複数のコンテナ・ランタイムをサポートします。
Docker は最も一般的に知られているランタイムであり、Docker 用語でポッドを説明するのに役立ちます。

ポッドの共有コンテクストとは、Linux 名前区間（namespace）、コントロール・グループ（cgroup）、その他の独立（isolation）に関する面（facet：ファセット）の集まりであり、これは Docker コンテナにおける独立（isolate）と同じものです。
ポッドのコンテクストでは、個々のアプリケーションがさらに下位の独立（sub-isolations）をしている場合があります。

ポッド内のコンテナは IP アドレスをとポート範囲を共有し、お互いを `localhost` を経由して発見できます。
また、SystemV セマフォや POSIX 共有メモリのように、標準プロセス間通信（IPC）を使っても相互に通信できます。
違うポッドにあるコンテナは相異なる IP ドレスを持つため、 IPC では [特別な設定](/jp/docs/concepts/policy/pod-security-policy/) がなければ通信できません。
コンテナの通信は、常にポッドの IP アドレスを経由して行います。

また、ポッド内のアプリケーションは共有ボリュームに接続できます。
共有ボリュームはポッドの一部として定義されるもので、各アプリケーションのファイルシステムにマウントして利用できます。

[Docker](https://www.docker.com/) の概念における言葉を使うと、名前空間を共有する Docker コンテナと共有 [ボリューム](/jp/docs/concepts/storage/volumes/) のグループとしてモデル化したもの（雛形にしたもの）がポッドです。

個々のアプリケーション・コンテナのように、ポッドとは（常に使うものと比べて）比較的に短期間の存在（ephemeral entity）と考えられます。
[ポッドの一生（life of a pod）](/jp/docs/concepts/workloads/pods/pod-lifecycle/) で論じているように、ポッドを作成すると、ユニークな ID （UID）が割り当てられ、終了もしくは削除されるまで、どこかのノード上で実行しつづけるようにスケジュール（計画）されます。
ノードが停止すると、タイムアウト時間（一定の停止時間）を経過後、そのノードに対するスケジュールは削除されます。
対象のポッド（UID によって定義されます）が新しいノードに「再スケジュール（rescheduled）」されるのではありません。
そのかわりに、全く同じポッドに置き換えられます。必要があれば同じ名前にできますが、新しい UID を割り当てられます（詳細は [replication controller（レプリケーション・コントローラ）](/jp/docs/concepts/workloads/controllers/replicationcontroller/) をご覧ください。）。

もし誰かがボリュームなどがポッドと同じライフタイムを持つと言及する場合は、ポッドが（その UID で）存在する限り（ボリュームなどが）存在するという意味です。
ポッドが何らかの理由によって削除された場合、たとえ全く同じものに置き換えるための再作成だとしても、関連したもの（例：ボリューム）も同時に削除され、新しいものが再び作られます。

{{< figure src="/images/docs/pod.svg" title="pod diagram" width="50%" >}}

*file puller（ファイル取得）とウェブサーバと、この複数のコンテナがあるポッドは、コンテナ間で共有するストレージとして、持続ボリューム（persistent volume）を使います。*

## ポッドの目的（モチベーション） {#motivation-for-pods}

### 管理 {#management}

ポッドとは、密接なサービス単位が提供する、複数の協働（協調しながら動作する）プロセスのパターンをモデル化したものです。
アプリケーションの構成要素の集まりと比較し、高いレベルの抽象化によってアプリケーションの展開と管理を簡単にします。
ポッドが提供するのは展開（デプロイメント）、水平スケール、複製（レプリケーション）の単位（ユニット）です。
同じ場所にあり（同時にスケジュールし）、命運を共にし（つまり、削除です）、複製を調整し、リソースを共有し、ポッド内におけるコンテナの依存性を自動的に管理します。

### リソース共有と通信 {#resource-sharing-and-communication}

ポッドは構成要素間でのデータの共有と通信を可能にします。

ポッド内のアプリケーションは、共通のネットワーク名前空間（同じ IP アドレスとポート範囲）を使います。
そして、さらに通信するためには `localhost` を使って相互に「発見」できます。
このため、ポッド内のアプリケーションは使用するポートの調整が必須です。
各ポッドは IP アドレスを平らに共有するネットワーク範囲を持っているため、ポッドは他の物理コンピュータやネットワークを横断するポッドと完全に通信できます。

ポッド内のアプリケーション・コンテナのホスト名には、ポッドの名前が設定されます。
詳細は [ネットワーク機能](/jp/docs/concepts/cluster-administration/networking/) をご覧ください。

アプリケーション・コンテナが定義するのは、ポッド内で何を実行するかに加え、ポッドの共有ストレージ・ボリュームのセットも定義します。
ボリュームはコンテナを再起動してもデータを残し続けるのが可能であり、ポッド内のアプリケーション間でデータを共有できます。

## ポッドの使い方 {#uses-of-pods}

（LAMP のような）アプリケーション・スタック（積み重ね）としてホストを水平統合するためにポッドを使えます。しかし、ポッドの主な目的は、次のような、同じ場所にあり、同時に管理するのに役立つプログラムをサポートするためです：

* コンテンツの管理システム、ファイル、データ読み込み、ローカルキャッシュ管理など。
* ログとチェックポイントのバックアップ、圧縮、ローテーション、スナップショットなど。
* データ変更監視、ログの追跡、ログ機能と監視のためのアダプタ、イベント送信（パブリッシャー）など
* プロキシ、ブリッジ、アダプタ
* コントローラ、マネージャ、設定変更（コンフィギュレータ）、アップデータ

一般的に、個々のポッドでは同じアプリケーションを複数実行するのは意図されていません。

より長い説明は、 [分散システムツールキット：コンテナが混在するためのパターン(https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns) をご覧ください。

## 代替案の考慮 {#alternatives-considered}

_なぜ複数のプログラムを１つの（Docker）コンテナで実行しないのでしょうか？_

1. 透明性です。ポッド内のコンテナがインフラ（基盤）から見えるようにするため、プロセス管理とリソース監視のように、インフラがコンテナに対するサービスを提供可能になります。
1. ソフトウェア依存性を切り離します。個々のコンテナは、別々にバージョン管理、再構築（リビルド）、再配置（リデプロイ）されます。Kubernetes は各コンテナの個別なライブ・アップデートに対応しています。
1. 扱うのが簡単です。ユーザは自分でプロセス・マネージャを実行する必要は無く、シグナルや終了コードの伝播（プロパゲーション）などの心配が不要です。
1. 効率性です。基盤（インフラ）側が責任を取るため、コンテナは軽量なままです。

_なぜアフィニティ（親和性）をベースとしたコンテナの協働スケジューリングをサポートしないのですか？_

この手法は同じ場所での動作（co-location）を提供しますが、リソース共有、IPC、同時終了の保証（guaranteed fate sharing）、シンプルな監視など、ポッドの大部分の利点を提供しません。

## ポッドの耐久性（あるいは耐久性の欠如） {#durability-of-pods-or-lack-thereof}

ポッドを耐久性があるものとして扱うのは意図していません。
スケジューリングの失敗、ノードの障害、リソースの欠乏やノードのメンテナンスなど、その他の退去（eviction）があれば存続しません。

通常、ユーザはポッドを直接作成する必要はありません。
ほとんどの場合、常に個々のコントローラ（例：([Deployments（デプロイメント）](/jp/docs/concepts/workloads/controllers/deployment/)）を使うべきでしょう。
コントローラはクラスタ領域内で自己修復（セルフ・ヒーリング）を提供するだけでなく、複製（レプリケーション）と展開（ロールアウト）も管理します。また、[StatefulSet（ステートフルセット）](/docs/concepts/workloads/controllers/statefulset/) のようなコントローラは、ステートフルな（状態を保存する）ポッドのサポートを提供できます。

[Borg](https://research.google.com/pubs/pub43438.html)、 [Marathon](https://mesosphere.github.io/marathon/docs/rest-api.html)、 [Aurora](http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema)、 [Tupperware](http://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997) といった
クラスタ・スケジューリング・リステムに比べると、ユーザが直面するのは API の集合を使った操作です。

ポッドを使いやすくするために、プリミティブを外に向かって公開（expose）します：

* スケジューラとコントローラを取り付け・取り外しやすいようにする（pluggability）
* コントローラ API を「代理」（proxy）することなく、ポッド単位での操作を可能とする
* 起動時の処理（ブートストラッピング）のようなコンテナのライフタイムと、ポッドのライフタイムを切り離す
* コントローラとサービスを切り離す。つまり、エンドポイント・コントローラはポッドしか監視しない
* kubelet レベルの機能性をクラスタ・レベルの機能性と共にクリーンにするため、kubelet は効率的な「ポッド・コントローラ」である
* アプリケーションの高可用性のためには、退去計画（planned eviction）やイメージの先行取得（image prefetching）のように、ポッドを事前に置き換え（リプレース）たり、ポッドの確実な事前削除を行ったりする可能性があります。

## ポッドの終了 {#termination-of-pods}

ポッドとは、クラスタ内のノード上で実行するプロセスを表しているため、各プロセスの必要性がなくなれば、プロセスを丁寧に終了（gracefully terminate）するのは重要です（対して、KILL シグナルで手荒に停止すると、クリーンアップするための機会も与えません）。
ユーザは削除の要求を送れるようにすべきであり、いつプロセスが終了（terminate）するかを知れるようにする必要があります。
しかしまた、最終的に確実に削除完了とする必要もあります。
ユーザがポッドの削除をシステム・レコードに対して要求する時には、ポッドを強制的に停止可能にするのではなく、猶予期間（grace period）に到達するまで停止できるよう、各コンテナ内のメインプロセスに対して TERM シグナルを送信します。
猶予期間が時間切れとなれば、KILL シグナルを各プロセスに対して送信し、API サーバからポッドが削除されます。
もしもプロセス終了の待機中に kubelet やコンテナ・マネージャが再起動した場合は、猶予期間に到達していなければ停止を再試行します。

例となるフロー:

1. ユーザはポッドを削除するためにコマンドを送信します。デフォルトの猶予期間は 30 秒です。
1. API サーバ内では、猶予期間内にポッドが「dead」（停止）に更新されるとみなされます。
1. クライアントで一覧コマンドを実行すると、ポッドは「Terminating」（停止中）として表示されます。
1. （3 と似ていますが）Kubelete を見ると、ポッドは停止中のマークが付けられて見えます。これは 2 の手順が開始され、ポッドの停止手続きが始まったからです。
    1. もしもポッドに [preStop hook（停止前フック）](/jp/docs/concepts/containers/container-lifecycle-hooks/#hook-details) の指定があれば、ポッドの中で呼び出されます。もしも `preStop` フックが猶予期間が切れても実行中であれば、手順 2 は短い間（2秒）猶予期間が延長されます。
    1. ポットの中にプロセスに対して `TERM` シグナルが送信されます。
1. （3 と似ていますが）サービスの一覧からポッドのエンドポイントが削除され、レプリケーション・コントローラからは実行中のポッドを構成する一部とは認識されません。ポッドの停止（シャットダウン）が緩やかですが、（サービス・プロキシのように）負荷分散のトラフィック提供は継続できないため、ローテーションから削除されます。
1. 猶予期間が切れると、ポッド内のあらゆるプロセスは SIGKILL で停止させられます。
1. 最終的に Kubelet は API サーバの猶予期間を０秒とし（直ちに削除）、ポッドの削除を完了します。API からポッドは消滅し、クライアントからは二度と見えなくなります。

### ポッドの強制削除 {#force-deletion}

ポッドの強制削除とは、クラスタの状態と etcd からポッドを直ちに削除するものと定義されています。強制削除が行われると、apiserver は kuberlet からの確認を待ちません。
つまり、ノード上のポッドが稼働中であっても直ちに停止させられます。
API からポッドは直ちに停止させられるため、同じ名前のポッドが作成可能になります。
ノード上では、ポッドはただちに停止状態にセットされるため、短時間の猶予なく強制的に削除されます。

ポッドによっては強制削除は危険であり、実施には注意を払うべきです。StatefulSet ポッドの場合、 [StatefulSet からポッドを削除](/jp/docs/tasks/run-application/force-delete-stateful-set-pod/) にあるタスク・ドキュメントをご覧ください。

## ポッド・コンテナ用の特権モード {#-rivileged-mode-for-pod-containers}

Kubernetes v1.11 から、ポッド内のあらゆるコンテナが特権モード（privileged mode）を有効化できるようになりました。
そのためには、コンテナ spec の `SecurityContext` で `privileged` フラグを使います。
これはネットワーク・スタックとデバイスに接続して操作するような、 Linux ケーパビリティ（capability）を使いたいコンテナ用に役立ちます。

もしもマスタで実行している Kubernetes が v1.1 以上で、ノードで実行しているバージョンが v1.1 よりも低ければ、新しい特権ポッドは api-server では受け入れられますが、起動できません。
保留中（pending）の状態になります。ユーザが `kubectl describe pod FooPodName` を呼び出すと、なぜポッドが保留状態になっているかの理由が表示されます。
コマンドの出力でイベント・テーブルにある説明は、次のようなものです:
`Error validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '<*>(0xc2089d3248)true'`

もしもマスタで実行しているバージョンが v1.1 よりも低ければ、特権ポッドは作成できません。
ユーザが特権コンテナを持つポッドの作成を試みても、次のようなエラーを受け取るだけです:
`The Pod "FooPodName" is invalid.
spec.containers[0].securityContext.privileged: forbidden '<*>(0xc20b222db0)true'`


## API オブジェクト {#api-object}

ポッドは Kubernets REST API においてはトップ・レベルのリソースです。API オブジェクトの詳細については [ポッド API オブジェクト](/jp/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#pod-v1-core) をご覧ください。


{{% /capture %}}