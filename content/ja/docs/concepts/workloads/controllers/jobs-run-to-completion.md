---
title: Job（ジョブ） - 完了する実行
content_template: templates/concept
weight: 70
---

{{% capture overview %}}

_job（ジョブ）_ は１つまたは複数のポッドを作成し、指定した数の終了（terminate）が成功するようにします。
ポッドの処理が成功すると、 _job_ トラックは処理完了になります。
処理完了が指定数に到達すると、ジョブ自身が完了となります。
ジョブの削除は、ジョブによって作成されたポッドをクリーンアップ（掃除）します。

簡単な例は、あるポッドに対して確実に処理を行いたい１つのジョブ・オブジェクトの作成です。
１つめのポッドが失敗または削除されると（たとえば、ノードのハードウェア障害やノードの再起動が原因で）、ジョブ・オブジェクトは新しいポッドを開始します。

また、ジョブは複数のポッドで並列に実行できます。


{{% /capture %}}

{{< toc >}}

{{% capture body %}}

## サンプル・ジョブの実行 {#running-an-example-ojb}

ここにあるのはサンプルのジョブ設定です。
 π を 2000 回計算し、出力します。

{{< codenew file="controllers/job.yaml" >}}

このサンプル・ジョブ緒w実行するには、サンプル・ファイルをダウンロードして実行するために、こちらのコマンドを実行します：

```shell
$ kubectl create -f https://k8s.io/examples/controllers/job.yaml
job "pi" created
```

ジョブの状態を確認するには、このコマンドを使います:

```shell
$ kubectl describe jobs/pi
Name:             pi
Namespace:        default
Selector:         controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
Labels:           controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                  job-name=pi
Annotations:      <none>
Parallelism:      1
Completions:      1
Start Time:       Tue, 07 Jun 2016 10:56:16 +0200
Pods Statuses:    0 Running / 1 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                job-name=pi
  Containers:
   pi:
    Image:      perl
    Port:
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:        <none>
    Mounts:             <none>
  Volumes:              <none>
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  1m           1m          1        {job-controller }                Normal      SuccessfulCreate  Created pod: pi-dtn4q
```

ジョブを完了したポッドを見るには、 `kubectl get pods` を使います。

マシンでジョブを読み込んでいるポッドの一覧を表示するには、次のようなコマンドを使います:

```shell
$ pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath={.items..metadata.name})
$ echo $pods
pi-aiw0a
```

これで、セレクタはジョブに対するセレクタと同じになりました。
`--output=josnpath` オプションの指定が表しているのは、戻ってきた一覧から、各ポッドの名前のみを取得します。

ポッドの１つの標準出力を表示します:

```shell
$ kubectl logs $pods
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
```

## ジョブの Spec を書く {#writing-a-job-spec}

他の全ての Kubernetes 設定ファイルと同様に、ジョブには `apiAversion`、 `kind` 、 `metadata` フィールドが必要です。

また、ジョブには [`.spec` セレクション](https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status) も必要です。

### ポッド・テンプレート {#pod-template}

`.spec.template` は `.spec` で唯一必須なフィールドです。

`.spec.template` は [ポッド・テンプレート](/ja/docs/concepts/workloads/pods/pod-overview/#pod-templates) です。
これはほとんど [ポッド](/ja/docs/concepts/workloads/pods/pod/) と同じスキーマですが、ネストされるのと `apiVersion` や `kind` を持たないのだけを除きます。

ポッドに対して必要なフィールドを追加するには、ポッド・テンプレート内のジョブに対して適切なラベルの指定（詳細は [ポッド・セレクタ](#pod-selector) ）と再起動方針の指定が必要です

### ポッド・セレクタ {#pod-selector}

`.spec.selector` フィールドはオプションです。
ほとんどのケースでこれを指定すべきではありません。
[自分でポッド・セレクタを指定](#specifying-your-own-pod-selector) をご覧ください。

### 並列ジョブ（Parallel Jobs） {#parallel-jobs}

ジョブには主に３つのタイプがあります:

1. 並列ではないジョブ
  - 通常はポッドが開始した時のみで、ポッド障害時は除く
  - ポッドの停止（terminates）に成功すると、ただちにジョブも完了
1. *fixed completion count* （固定した完了数）を持つ並列ジョブ：
  - 0 ではない整数を `.spec.completions` に指定
  - 1 から `.spec.completions` までの値のポッドが成功すると、ジョブが完了
  - **未実装：** １から `.spec.completions` まで、各ポッドは異なるインデックスを持つ
1. *work queue* （動作キュー）を持つ並列ジョブ：
  - `.spec.completions` を指定せず、デフォルトは `.spec.parallelism`
  - ポッドは自分自身または外部のサービスを通し、何を処理すべきか決定する必要がある
  - ポッドは各々のピア（末端）として独立して何を行ったかどうかを決められる能力が必要であり、ここにはジョブの処理全体も含める
  - _あらゆる_ ポッドの完了が成功したら、新しいポッドを作成しない
  - 少なくとも１つのポッドの成功が完了（terminated）すると、全てのポッドが削除され、ジョブも成功として処理が完了する。
  - あらゆるポッドの成功が終了（exited)すると、他のポッドは何も処理しないか、何も出力しない。そして、残った全てのプロセスを終了（exit）する。

並列ではないジョブの場合は  `.spec.completions` と  `.spec.parallelism` のいずれも設定不要です。
どちらも設定しなければ、いずれもデフォルトの 1 になります。

固定完了カウント・ジョブ（Fixed Completion Count job）の場合、 `.spec.completions` が終了数の指定のために必要になります。
 `.spec.parallelism` を指定できますし、未指定のままであればデフォルトの 1 になります。

ワーク・キュー・ジョブ（Work Queue Job）の場合、 `.spec.completions` は未指定のままにする必要があり、また、  `.spec.completions`  は負ではない整数の指定が必要です。

異なるジョブの使い方に関する情報は  [ジョブ・パターン](#job-patterns)  をご覧ください。

#### 並列化の制御 {#controlling-parallelism}

並列化の要求（ `.spec.parallelism` ）には、あらゆる負ではない整数を設定できます。
指定しなければ、デフォルトの 1 になります。
0 を指定すると、ジョブのカウント数が増えないため、事実上の停止となります。

実際の並列化（あらゆるインスタンス上で実行するポッドの数）にあたっては、様々な理由によって、並列化を要求した数よりも少なくなります：

- Fixed Completion Count ジョブでは、実際に並列で実行されるジョブ数は、完了に達する数を超えない。 `.spec.parallelism` で指定したよりも高い値は無視される
- ワークキュー・ジョブでは、何らかのポッドが成功（succeeded）すると、新しいポッドは開始しない。ただし、既に動いているポッドは完了（complete）できる
- コントローラが反応する時間が無い
- コントローラは何らかの理由によってポッド作成に失敗し（ResourceQuote 不足、権限不足、など）、いくつかの追加ポッドがリクエストされる
- 以前に同じ名前のジョブが失敗していると、コントローラは新しいポッド作成を絞る
- ポッドが丁寧な（gracefully）シャットダウンをすると、停止まで時間がかかる

## ポッドとコンテナ障害の扱い {#handling-pod-and-container-failures}

ポッド内のコンテナは複数の理由によって障害（fail）となる可能性があります。
たとえば、プロセスが0以外の終了コードで終了したり、メモリ制限に達したためコンテナが強制停止（kill）されたりです。
障害が起こると、 `.spec.template.spec.restartPolicy = "OnFailure"` となり、ノード上のポッドは維持されたままですが、コンテナは再実行されます。
それゆれ、プログラムが障害発生時にローカルでリスタートできるように扱えるようにするか、あるいは `.spec.template.spec.restartPolicy = "Never"` を指定する必要があります。
`restartPolicy` （再起動方針）の詳しい情報については [pods-states](/docs/concepts/workloads/pods/pod-lifecycle/#example-states) をご覧ください。

また、いくつかの理由によるポッド全体で障害も起こります。
たとえば、ノードによってポッドがキック・オフ（追い出され）たり（ノードの更新、再起動、削除、など）、あるいはポッドのコンテナで障害がおこり、かつ `.spec.template.spec.restartPolicy = "Never"` の場合です。
ポッドが障害になると、ジョブ・コントローラは新しいポッドを開始します。
そのため、プログラムは新しいポッドが再起動した場合の処理を扱う必要があります。
とりわけ必要なのは、以前の実行によって行われた一次ファイル、ロック、完了していない出力の扱いです。

たとえ `.spec.parallelism = 1` と `.spec.completions = 1` と `.spec.template.spec.restartPolicy = "Never"` を指定したとしても、同じプログラムが時々２つ同時に起動する場合がありますのでご注意ください。

`.spec.parallelism` と `.spec.completions` を、どちらも１以上指定した場合、複数のポッドが同時に実行される場合があります。
そのため、ポッドが同時の実行処理に耐えうるようにする必要があります。

### ポッド・バックオフ障害方針（#pod-backoff-failure-policy）

設定ファイル上の論理エラー等によって、ジョブが失敗した後も、リトライを繰り返したい場合があります。
このような時は、ジョブが失敗したと考えられる前にリトライする数を `.spec.backoffLimit` で設定します。
バックオフ・リミット（back-off limit）はデフォルトでは6に設定されています。
ジョブに関連するポッドで障害が起こると、ジョブ・コントローラは指数関数的にバック・オフ遅延（10秒、20秒、40秒…）を6分間を上限とする再作成を繰り返します。
ジョブの次の状態チェックの前に新しいポッド障害が派生しなければ、バック・オフカウントはリセットされます。

{{< note >}}
**メモ：** 衆知の問題 [#54870](https://github.com/kubernetes/kubernetes/issues/54870) によると、  `.spec.template.spec.restartPolicy` フィールドを `OnFailure` と設定すると、バック・オフ制限が効かなくなります。
短期間のワークアラウンドであれば、embedded テンプレートに対する再起動ポリシーは "`Never`" に設定します。
{{< /note >}}

## ジョブの終了とクリーンアップ {#job-termination-and-cleanup}

ジョブが完了すると、それ以上のポッドは作成されませんが、ポッドもまた削除されません。
ポッドが維持されているのは、完了したポッドのログを確認し、エラー、警告、その他の判断用の出力を確認できるようになっています。
ジョブ・オブジェクトもまた完了後に残り続けているため、状態を確認できます。
ユーザ次第で、状態の確認後に古いジョブを削除できます。
ジョブの削除は `kubectl` で行います（例：  `kubectl delete jobs/pi` or `kubectl delete -f ./job.yaml`）。
`kubectl` を使ってジョブを削除すると、作成されたポッドも削除されます。

デフォルトでは、ポッドはポッドの障害による中断がなければ、ジョブは `.spec.backoffLimit`  を保留します。
あるいは、別のジョブ削除方法として、アクティブなデッドラインを設定できます。
この設定をするには、ジョブの `.spec.activeDeadlineSeconds` フィールドで秒数を指定します。

`activeDeadlineSeconds` にはジョブの存続期間を適用するもので、ポッドをいくつ作成しようと関係ありません。
ひとたびジョブが `activeDeadlineSeconds` に到達すると、ジョブとジョブを持っているポッドの一覧を停止（terminated）します。
その結果、ジョブの状態は `reason:DeadlineExceeded` （デッドラインに到達）となります。

ジョブの `.spec.activeDeadlineSeconds` は自身の `.spec.backoffLimit` よりも優先されます。
そのため、ジョブはポッドの１回または複数の障害によって再試行されますが、指定した `activeDeadlineSeconds` の時間制限に到達すると、追加のポッドを展開（デプロイ）しません。この時、たとえ `backoffLimit` には到達していなくてもです。

例:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-with-timeout
spec:
  backoffLimit: 5
  activeDeadlineSeconds: 100
  template:
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
```

ジョブ Spec とジョブ内の [ポッド・テンプレート Spec](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#detailed-behavior) は `activeDeadlineSeconds` フィールダウがあります。
このフィールドは適切なレベルに確実に指定してください。

## ジョブ・パターン {#job-patterns}

ジョブ・オブジェクトはポッドの信頼できうる並列実行をサポートします。
ジョブ・オブジェクトは並列化プロセスが密接に通信できるようにするための、通常の計算科学で見られるような設計をサポートしていません。
個々には並列化プロセスをサポートしていませんが、 関連した *work items* があります。
これらによって、メールを送ったり、フレームをレンダーしたり、ファイルを送ったり、NoSQL でキーの幅や、データベースのスキャンなどができます。

複雑なシステムでは、work items で様々な設定ができます。
ここにあるのは work items のセットの例であり、ユーザによっては *batch job（バッチジョブ）* と一緒に管理したい場合もあるでしょう。

並列化計算には複数のパターンがありますが、どれも利点と欠点があります。
トレードオフとは：

ｰ work item ごとに１つのジョブ・オブジェクトを作成 vs 全ての work item に対して１つのジョブ・オブジェクトを作成。後者は多くの数の work item で有利。前者はユーザとシステムにとっては大量のジョブ・オブジェクトを管理する必要があるためオーバヘッドになる。
- ポッドの作成数は work item 数と同じ vs 書くポッドは複数の work item を処理。前者は典型的に必要なのは、既存のコードやコンテナに対する変更がより少ない。後者は多くの work items 数だが、前項と似たような問題。
- 複数のアプローチをワーク・キューで使う。複数のキュー・サービスの実行が必要であり、ワーク・キューを利用できるようにするには、既存のプログラムやコンテナに対する変更が必要になる。他のアプローチは簡単に既存のコンテナ化アプリケーションを導入できる。

トレードオフを要約したのがこちらです。列２～４が前述のトレードオフに相当します。
また、パターン名のリンク先にサンプルと詳細な説明があります。

|                            パターン                                   | 単一ジョブ・オブジェクト | ポッドが works item より少ないか？ | 使用するアプリは変更しないか？ |  Kube 1.1で動くか？ |
| -------------------------------------------------------------------- |:-----------------:|:---------------------------:|:-------------------:|:-------------------:|
| [ジョブ・テンプレート拡張](/ja/docs/tasks/job/parallel-processing-expansion/)            |                   |                             |          ✓          |          ✓          |
| [Work Item ごとにポッドでキュー](/ja/docs/tasks/job/coarse-parallel-processing-work-queue/)   |         ✓         |                             |      sometimes      |          ✓          |
| [可変ポッド・カウントでキュー](/ja/docs/tasks/job/fine-parallel-processing-work-queue/)  |         ✓         |             ✓               |                     |          ✓          |
| 単一ジョブに静的な Work を割り当て                               |         ✓         |                             |          ✓          |                     |

各ポッドを作成するとき、ジョブ・コントローラによって `.spec.completions` を指定すると、同一の  [`spec`](https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status) を持ちます。
つまり、全てのポッドが同じコマンドライン、同じイメージ、同じボリューム、（ほとんど）同じ環境変数を持ちます。
これらのパターンはポッドの組み合わせにより、動作に様々な影響を与えます。

こちらの表は `.spec.parallelism` と `.spec.completions` を各パターンごとの設定で必要なものを示します。
この `W` とは work item の数です。

|                             パターン                                  | `.spec.completions` |  `.spec.parallelism` |
| -------------------------------------------------------------------- |:-------------------:|:--------------------:|
| [ジョブ・テンプレート拡張](/ja/docs/tasks/job/parallel-processing-expansion/)           |          1          |     1 であるべき     |
| [Work Item ごとにポッドでキュー](/ja/docs/tasks/job/coarse-parallel-processing-work-queue/)   |          W          |        何でも           |
| [可変ポッド・カウントでキュー](/ja/docs/tasks/job/fine-parallel-processing-work-queue/)  |          1          |        何でも           |
| 単一ジョブに静的な Work を割り当て                               |          W          |        何でも           |


## 高度な使い方 {#advanced-usage}

### 自身のポッド・セレクタを指定 {#specifying-your-own-pod-selector}

システムはジョブの作成時、デフォルトでは論理的にこのフィールドを追加します。
ここで選択される値は、他のジョブとは重複しません。

しかし、いくつかの場合において、自動的に設定されるセレクタを上書きしたい必要があるでしょう。
そのような場合は、ジョブに対して `.spec.selector` を指定できます。

この作業を行うには非常に注意が必要です。
ジョブのポッドに対してユニークではないラベル・セレクタを指定してしまうと、関係のないポッドに一致してしまう可能性があり、関係の無いポッドのジョブが削除されるか、あるいはそのジョブが他のポッドと競合するか、あるいは両方のジョブが競合によってポッドの作成が拒否される場合があります。
ユニークではないセレクタを選択してしまうと、他のコントローラ（例：ReplicationController） や他のポッドも予測できない挙動となる可能性があります。
`.spec.selector` の指定を間違えたとしても、Kubernetes はそれを止められません。

ここにある例は、将来的に皆さんが使いたくなるものかもしれません。

ジョブ `old` が既に実行中とします。
既存のポッドは実行中のままにし、これから作成するポッドに対しては、異なったポッド・テンプレートを使い、ジョブに対しては新しい名前を与えたい場合があるでしょう。
各フィールドは更新できないため、ジョブは更新できません。
そのため、 ジョブ `old` を削除し、実行中のポッドから話すには、 `kubectl delete job/old --cascade=false` を使います。
削除する前に、どのセレクタを使うかメモをとっておきます：

```
kind: Job
metadata:
  name: old
  ...
spec:
  selector:
    matchLabels:
      job-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
```

それから、ジョブ名 `new` という新しいジョブを作成し、同じセレクタを明示的に指定します。
既存のポッドのラベルは `job-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002` なので、新しいジョブ `new` からも同様に制御できます。

新しいジョブでは `manualSelector: true`  を指定する必要があります。これは、セレクタが使っていないもの、これは、システムによって通常自動的に作成されないものを選択します。

```
kind: Job
metadata:
  name: new
  ...
spec:
  manualSelector: true
  selector:
    matchLabels:
      job-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
```

新しいジョブ自身は `a8f3d00d-c6d2-11e5-9f87-42010af00002` とは異なる UID を持っています。
システムに対して `manualSelector: true` を設定するとは、自分自身でこの不一致に対してどのような対処をするのか知っている場合に行います。

## 別の方法 {#alternatives}

### ベア・ポッド（Bare Pods） {#bare-pods}

再起動や障害時にポッドが実行中だとしても、停止されたポッドは再起動されないのでご注意ください。
ただし、ジョブが停止されたポッドに置き換えるため、新しいポッドを作成します。
そのため、私たちが推奨するのはジョブを使うのではなく、単なるポッドを使う方法です。たとえアプリケーションが必要なのが１つのポッドだとしてもです。

### レプリケーション・コントローラ {#replication-controller}

ジョブは [レプリケーション・コントローラ](/ja/docs/user-guide/replication-controller) を補完するものです。
レプリケーション・コントローラによるポッドの管理には、停止（例：ウェブ・サーバ）を想定していません。また、ジョブの管理するポッドは停止を想定しています（例：バッチ・ジョブ）。

[ポッド・ライフサイクル](/ja/docs/concepts/workloads/pods/pod-lifecycle/) に関する議論においては、 `ジョブ` とはポッドに対して *唯一* 適切なのは 'RestartPolicy' が `OnFailure` または `Never` です。（メモ： `RestartPolicy` を指定しなければ、デフォルト値は `Always` です）

### シングル・ジョブでコントローラ・ポッドを開始 {#single-job-starts-controller-pod}

シングル・ジョブに対する他のパターンは、ポッドを作成するために他のポッドを作成することです。各ポッドに対して様々な種類のコントローラを動かします。
これによって、最も柔軟性を得られます。
しかし、始めるにあたっては何らかの複雑さがあり、Kubernetes との統合もしづらくなります。

このパターンの例としては、ジョブをポッドで開始するにあたってスクリプトで Spark マスタ・コントローラを開始し([spark サンプル](https://github.com/kubernetes/examples/tree/{{< param "githubbranch" >}}/staging/spark/README.md)をご覧ください）、spark ドライバを実行し、その後クリーンアップする場合でしょう。

この手法の利点は、全体的なプロセスが完全なジョブ・オブジェクトの実行を保証します。
しかしなが、完全な制御を及ぼせるのはポッドの作成時と、処理がポッドに割り当てられた時のみです。

## cron ジョブ {#cron-jobs}

Kubernetes [1.4](https://github.com/kubernetes/kubernetes/pull/11980) では時間と日付（cron のように）を指定するジョブの作成をサポートしました。
詳しい情報については  [cron ジョブ・ドキュメント](/ja/docs/concepts/workloads/controllers/cron-jobs/) をご覧ください。

{{% /capture %}}
